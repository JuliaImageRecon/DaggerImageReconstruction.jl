var documenterSearchIndex = {"docs":
[{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"worker = 1 # hide\nusing DaggerImageReconstruction # hide","category":"section"},{"location":"generated/example/algorithm/#Distributed-Image-Reconstruction","page":"Algoritm Interface","title":"Distributed Image Reconstruction","text":"This example demonstrates how to execute an iterative Radon reconstruction using the OurRadonReco package on a separate process. We start by adding a new worker process:\n\nusing Distributed\nworker = first(addprocs(1))\n\nIn this example we create a new local process, but usually one would create a process on another machine for example via ssh.\n\nWe retrieve the worker's ID, which will be used to designate the target for our algorithm. Ensure that required packages are loaded on both the main and worker processes:\n\n@everywhere using OurRadonReco\n\ninclude(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/example/algorithm/#Iterative-Radon-Reconstruction","page":"Algoritm Interface","title":"Iterative Radon Reconstruction","text":"We first recall the algorithms we defined for OurRadonreco. We will use iterative methods to reconstruct the first three images from our time series. For more information, refer to the AbstractImageReconstruction documentation. We first prepare our parameters. For this example we will use the Conjugate Gradient Normal Residual solver with 20 iterations and a L2 regularization of 0.001. Furthermore, we will project the final result to positive values:\n\npre = RadonPreprocessingParameters(frames = collect(1:3))\niter_reco = IterativeRadonReconstructionParameters(; shape = size(images)[1:3], angles = angles, iterations = 20, reg = [L2Regularization(0.001)], solver = CGNR);\nnothing #hide\n\nWe can construct the algorithm with our parameters:\n\nalgo_iter = IterativeRadonAlgorithm(IterativeRadonParameters(pre, iter_reco));\nnothing #hide\n\nAnd apply it to our sinograms:\n\nimag_iter = reconstruct(algo_iter, sinograms);\nnothing #hide\n\nFinally we can visualize the results:\n\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_iter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig","category":"section"},{"location":"generated/example/algorithm/#Distributed-Iterative-Radon-Reconstruction","page":"Algoritm Interface","title":"Distributed Iterative Radon Reconstruction","text":"To execute the reconstruction process on our worker process we will use the DaggerReconstructionAlgorithm. This is an image reconstruction algorithm provided by DaggerImageReconstruction and features the same interface as other algorithms implemented with AbstractImageReconstruction. To use this algorithm, we again need to prepare our parameters:\n\niter_dagger = DaggerReconstructionParameter(algo = algo_iter, worker = worker);\nnothing #hide\n\nHere our parameter are give the complete iterative algorithm we constructed previously, as well as the worker. Internally, this moves the whole algorithm to the specified worker. If an algorithm contains a large amounts of data, such a transfer might be infeasible/costly. To avoid this, consider using the RecoPlan interface instead.\n\nOnce we have our parameters, we can construct our algorithm:\n\nalgo_dagger = DaggerReconstructionAlgorithm(iter_dagger);\nnothing #hide\n\nAfterwards, we can reconstruct as before:\n\nimag_dagger = reconstruct(algo_dagger, sinograms);\nnothing #hide\n\nThis moves the sinogram to the other process and performs the image reconstruction there. At the end the algorithm retrieves the result and we can treat it the same way as the local reconstruction:\n\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_dagger[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"worker = 1 # hide\n#using Distributed #hide\n#worker = first(addprocs(1)) #hide\nusing DaggerImageReconstruction # hide\ninclude(\"../../literate/example/example_include_all.jl\") #hide","category":"section"},{"location":"generated/example/daggerplan/#Distributed-Image-Reconstruction-using-RecoPlans","page":"RecoPlan Interface","title":"Distributed Image Reconstruction using RecoPlans","text":"This example demonstrates how to configure an iterative reconstruction algorithm directly on a worker, which helps to avoid transferring large parameters between processes and allows access to resources that may only exist on a specific worker.\n\nWe follow a similar procedure as with the algorithm interface, but we will not configure the parameters just yet.\n\npre = RecoPlan(RadonPreprocessingParameters)\niter_reco = RecoPlan(IterativeRadonReconstructionParameters)\nparams = RecoPlan(IterativeRadonParameters; pre = pre, reco = iter_reco)\nplan_iter = RecoPlan(IterativeRadonAlgorithm, parameter = params)\n\nWe can traverse the parameters of our algorithm and configure them locally:\n\nplan_iter.parameter.pre.frames = collect(1:3)\n\nTo transfer the plan to the worker process, we will use DaggerReconstructionParameter and DaggerReconstructionAlgorithm as a RecoPlan:\n\nparams_dagger = RecoPlan(DaggerReconstructionParameter; worker = worker, algo = plan_iter)\nplan_dagger = RecoPlan(DaggerReconstructionAlgorithm; parameter = params_dagger)\n\nIn this setup, only the DaggerReconstructionParameter and DaggerReconstructionAlgorithm exist on the local worker; all other RecoPlans reside on the chosen worker. When traversing the RecoPlan tree across workers, we receive a DaggerRecoPlan instead of the usual data type:\n\ntypeof(plan_dagger.parameter.algo)\n\n#This ephemeral structure manages communication with its remote `RecoPlan` counterpart, allowing us to use the same interface as if the entire plan were local.\nplan_dagger.parameter.algo.parameter.reco.solver = CGNR\n\ndict = Dict{Symbol, Any}()\ndict[:shape] = size(images)[1:3]\ndict[:angles] = angles\ndict[:iterations] = 20\ndict[:reg] = [L2Regularization(0.001)]\ndict[:solver] = CGNR\nsetAll!(plan_dagger, dict)\n\nTo configure the algorithm with resources only available on the worker, such as files or GPU data, we can use the following interface:\n\nsetproperty!(plan_dagger.parameter.algo.parameter.reco, :angles) do\n  angles[1:2:end]\nend\nlength(plan_dagger.parameter.algo.parameter.reco.angles) == length(1:2:length(angles))\n\nThe provided function is evaluated solely on the remote worker.\n\nOnce the algorithm is fully configured, we can build and use it as usual:\n\nsetAll!(plan_dagger, dict)\nimag_dagger = reconstruct(build(plan_dagger), sinograms)\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_dagger[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig","category":"section"},{"location":"generated/example/daggerplan/#Serialization","page":"RecoPlan Interface","title":"Serialization","text":"The serialization process of DaggerReconstructionAlgorithm and DaggerReconstructionParameter ignores the worker parameter and retrieves the entire plan tree:\n\ntoTOML(stdout, plan_dagger)\n\nIt is also possible to directly load and distribute a serialized plan from a file using:\n\nloadDaggerPlan(filename, modules; worker = worker)\n\nThis automatically wraps everything in a DaggerReconstructionAlgorithm.","category":"section"},{"location":"generated/example/daggerplan/#Observables","page":"RecoPlan Interface","title":"Observables","text":"RecoPlans can attach callbacks to property value changes using Observables from Observables.jl. If a RecoPlan is set up with listeners and then moved to a different worker, the plans execute within that worker. This functionality also applies to the loadDaggerPlan method mentioned earlier.\n\nAdditionally, listeners can be attached across workers using the Observable interface on a DaggerRecoPlan:\n\nusing Observables\nlocalVariable = 3\nplan_iter_remote = plan_dagger.parameter.algo\nfun = on(plan_iter_remote.parameter.pre, :frames) do newval\n  @info \"Number of frames was updated to: $(length(newval))\"\n  localVariable = length(newval)\nend\nsetAll!(plan_iter_remote, :frames, collect(1:42))\n\nNote: We retain the observable function in the variable fun to allow for later removal of the listener. The anonymous function cannot be used directly due to internal listener management in DaggerImageReconstruction.\n\noff(plan_iter_remote.parameter.pre, :frames, fun)\nsetAll!(plan_iter_remote, :frames, collect(1:32))\n\nSince the listener executes on the local worker, updated data must be transferred between workers. If this involves large data, a preprocessing function can be provided to the Observable:\n\nfun = on(plan_iter_remote.parameter.pre, :frames; preprocessing = length) do newval\n  @info \"Number of frames was updated to: $(newval)\"\n  localVariable = newval\nend\nsetAll!(plan_iter_remote, :frames, collect(1:42))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"example_intro/#Distributed-Radon-Image-Reconstruction","page":"Introduction","title":"Distributed Radon Image Reconstruction","text":"In this example, we will build upon the Radon example from AbstractImageReconstruction. We will demonstrate how our reconstruction package, OurRadonReco, can be distributed across multiple processes.","category":"section"},{"location":"example_intro/#Installation","page":"Introduction","title":"Installation","text":"In addition to the packages from the Radon example, you need to add DaggerImageReconstruction using the Julia package manager. Open a Julia REPL and execute the following command:\n\nusing Pkg\nPkg.add(\"DaggerImageReconstruction\")\n\nThis command will download and install DaggerImageReconstruction.jl along with its dependencies.","category":"section"},{"location":"example_intro/#Required-Packages","page":"Introduction","title":"Required Packages","text":"You will also need to install the necessary packages for the Radon example. Please refer to the example documentation for specific installation steps.\n\nNote that there is no direct dependency between OurRadonReco and DaggerImageReconstruction. While it is possible to specialize parts of the image reconstruction through package extensions, the core functionality is provided solely via the AbstractImageReconstruction interface.","category":"section"},{"location":"example_intro/#Environment-Setup","page":"Introduction","title":"Environment Setup","text":"Ensure that the required packages are installed in the environment of both Julia processes. For detailed instructions on launching Julia processes across different workers or computers, consult the Distributed Computing documentation.","category":"section"},{"location":"API/api/#API-for-DaggerImageReconstruction","page":"API Reference","title":"API for DaggerImageReconstruction","text":"This page contains documentation of the public API of the AbstractImageReconstruction. In the Julia REPL one can access this documentation by entering the help mode with ?","category":"section"},{"location":"API/api/#Algorithm-and-Parameters","page":"API Reference","title":"Algorithm and Parameters","text":"","category":"section"},{"location":"API/api/#DaggerRecoPlan","page":"API Reference","title":"DaggerRecoPlan","text":"","category":"section"},{"location":"API/api/#DaggerImageReconstruction.DaggerReconstructionAlgorithm","page":"API Reference","title":"DaggerImageReconstruction.DaggerReconstructionAlgorithm","text":"DaggerReconstructionAlgorithm\n\nStruct representing a Dagger-based reconstruction algorithm, which encapsulates the distrubted reconstruction execution and manages the outputs.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#DaggerImageReconstruction.DaggerReconstructionParameter","page":"API Reference","title":"DaggerImageReconstruction.DaggerReconstructionParameter","text":"DaggerReconstructionParameter\n\nStruct representing parameters for a Dagger-based reconstruction algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#DaggerImageReconstruction.DaggerRecoPlan","page":"API Reference","title":"DaggerImageReconstruction.DaggerRecoPlan","text":"DaggerRecoPlan{T}\n\nA configuration template for an image reconstruction algorithm or parameters of type T in a different Julia process. \n\nThe DaggerRecoPlan{T} struct provides an interface similar to that of a RecoPlan, with the key distinction that setting and getting properties results in transparent data transfer to the specified remote process. DaggerRecoPlans are temporary data structures that are recreated whenever traversing the remote RecoPlan tree. They track no state, except for the reference to their remote RecoPlan counterpart.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#Base.getproperty-Tuple{DaggerRecoPlan, Symbol}","page":"API Reference","title":"Base.getproperty","text":"Base.getproperty(plan::DaggerRecoPlan, name::Symbol)\n\nGet the property name of the counterpart plan. If the property is another RecoPlan, this returns a new DaggerRecoPlan pointing to the RecoPlan property.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.setproperty!-Tuple{DaggerRecoPlan, Symbol, Any}","page":"API Reference","title":"Base.setproperty!","text":"Base.setproperty!(plan::DaggerRecoPlan, name::Symbol, x)\n\nSet the property name of the remote plan to x. Equivalent to plan.name = x. Triggers callbacks attached to the property.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Observables.on-Tuple{Any, DaggerRecoPlan, Symbol}","page":"API Reference","title":"Observables.on","text":"on(f, plan::DaggerRecoPlan, property::Symbol; preprocessing = identity, kwargs...)\n\nRegisters a callback function f to be executed whenever the specified property of the given plan changes. The function f will be executed with the new value of the property on the current worker. Returns a Dagger.Chunk of the ObservableFunction. This chunk is required to unregister the listener f\n\nTo preprocess the data before it is passed to f, use the preprocessing keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#DaggerImageReconstruction.loadDaggerPlan","page":"API Reference","title":"DaggerImageReconstruction.loadDaggerPlan","text":"loadDaggerPlan(filename; worker)\n\nLoad a local RecoPlan from the specified filename and interpret it on the designated worker. The resulting RecoPlan is encapsulated within a DaggerReconstructionAlgorithm.\n\n\n\n\n\n","category":"function"},{"location":"#DaggerImageReconstruction.jl","page":"Home","title":"DaggerImageReconstruction.jl","text":"Distributed Image Reconstruction for Medical Image Reconstruction Packages","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"DaggerImageReconstruction.jl is a Julia package that enables distributed image reconstruction using AbstractImageReconstruction.jl across multiple Julia processes and machines. This flexibility allows users to configure image reconstruction locally while executing it on a remote machine, such as one with GPU acceleration.\n\nAny algorithm developed with AbstractImageReconstruction is compatible, including all algorithms from MPIReco.jl.\n\nThis package leverages the Distributed.jl standard library and Dagger.jl for its functionality.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Transparent data movement during image reconstruction \nSeamless usage of RecoPlans across processes, including tree traversal and observables\nLoading of local algorithms configuration on remote processes","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package, use Julia's package manager. Open the Julia REPL and run:\n\nusing Pkg\nPkg.add(\"DaggerImageReconstruction\")","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"To use DaggerImageReconstruction.jl, one first needs to add a new Julia process using Distributed:\n\n# Add new process (on remote server)\nusing Distributed\nworker = first(addprocs([\"gpuServer\"]))\n\nAfterwards one can load `DaggerImageReconstructionÂ´ and the packages implementing specific image reconstruction algorithms, such as MPIReco.jl. Similar to AbstractImageReconstruction.jl, this package does not offer concrete reconstruction algorithms:\n\nusing DaggerImageReconstruction\n@everywhere using AbstractImageReconstruction, ... # Load Reco packages\n\nplan = loadDaggerPlan(\"plan.toml\", ...; worker = worker)\n\n# Transparently configure algorithm in the remote process\ndict = Dict{Symbol, Any}()\ndict[:iterations] = 20\ndict[:file] = () -> File(\"path/on/remote\")\nsetAll!(plan, dict)\n\ndata = ... # read local data\n\n# Transfer data to the remote, reconstruct there and return the result\nalgo = build(plan)\nimage = reconstruct(algo, raw)\n\nAlgorithms can be parameterized and constructed as if they were local RecoPlans. The example above demonstrates moving the entire image reconstruction to another process. DaggerImageReconstruction also provides an AbstractUtilityReconstructionParameters to transfer individual processing steps to another process.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are welcome! If you would like to contribute to DaggerImageReconstruction.jl, please fork the repository and create a pull request.","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"This package is built on top of Dagger.jl, which provides the framefork for the distributed computations.","category":"section"}]
}
