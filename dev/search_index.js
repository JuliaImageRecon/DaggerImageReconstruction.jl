var documenterSearchIndex = {"docs":
[{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"worker = 1 # hide\nusing DaggerImageReconstruction # hide","category":"page"},{"location":"generated/example/algorithm/#Distributed-Image-Reconstruction","page":"Algoritm Interface","title":"Distributed Image Reconstruction","text":"","category":"section"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"This example demonstrates how to execute an iterative Radon reconstruction using the OurRadonReco package on a separate process. We start by adding a new worker process:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"using Distributed\nworker = first(addprocs(1))","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"In this example we create a new local process, but usually one would create a process on another machine for example via ssh.","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"We retrieve the worker's ID, which will be used to designate the target for our algorithm. Ensure that required packages are loaded on both the main and worker processes:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"@everywhere using OurRadonReco","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"include(\"../../literate/example/example_include_all.jl\") #hide","category":"page"},{"location":"generated/example/algorithm/#Iterative-Radon-Reconstruction","page":"Algoritm Interface","title":"Iterative Radon Reconstruction","text":"","category":"section"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"We first recall the algorithms we defined for OurRadonreco. We will use iterative methods to reconstruct the first three images from our time series. For more information, refer to the AbstractImageReconstruction documentation. We first prepare our parameters. For this example we will use the Conjugate Gradient Normal Residual solver with 20 iterations and a L2 regularization of 0.001. Furthermore, we will project the final result to positive values:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"pre = RadonPreprocessingParameters(frames = collect(1:3))\niter_reco = IterativeRadonReconstructionParameters(; shape = size(images)[1:3], angles = angles, iterations = 20, reg = [L2Regularization(0.001)], solver = CGNR);\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"We can construct the algorithm with our parameters:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"algo_iter = IterativeRadonAlgorithm(IterativeRadonParameters(pre, iter_reco));\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"And apply it to our sinograms:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"imag_iter = reconstruct(algo_iter, sinograms);\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"Finally we can visualize the results:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"fig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_iter[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/example/algorithm/#Distributed-Iterative-Radon-Reconstruction","page":"Algoritm Interface","title":"Distributed Iterative Radon Reconstruction","text":"","category":"section"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"To execute the reconstruction process on our worker process we will use the DaggerReconstructionAlgorithm. This is an image reconstruction algorithm provided by DaggerImageReconstruction and features the same interface as other algorithms implemented with AbstractImageReconstruction. To use this algorithm, we again need to prepare our parameters:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"iter_dagger = DaggerReconstructionParameter(algo = algo_iter, worker = worker);\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"Here our parameter are give the complete iterative algorithm we constructed previously, as well as the worker. Internally, this moves the whole algorithm to the specified worker. If an algorithm contains a large amounts of data, such a transfer might be infeasible/costly. To avoid this, consider using the RecoPlan interface instead.","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"Once we have our parameters, we can construct our algorithm:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"algo_dagger = DaggerReconstructionAlgorithm(iter_dagger);\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"Afterwards, we can reconstruct as before:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"imag_dagger = reconstruct(algo_dagger, sinograms);\nnothing #hide","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"This moves the sinogram to the other process and performs the image reconstruction there. At the end the algorithm retrieves the result and we can treat it the same way as the local reconstruction:","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"fig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_dagger[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"","category":"page"},{"location":"generated/example/algorithm/","page":"Algoritm Interface","title":"Algoritm Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"worker = 1 # hide\n#using Distributed #hide\n#worker = first(addprocs(1)) #hide\nusing DaggerImageReconstruction # hide\ninclude(\"../../literate/example/example_include_all.jl\") #hide","category":"page"},{"location":"generated/example/daggerplan/#Distributed-Image-Reconstruction-using-RecoPlans","page":"RecoPlan Interface","title":"Distributed Image Reconstruction using RecoPlans","text":"","category":"section"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"This example demonstrates how to configure an iterative reconstruction algorithm directly on a worker, which helps to avoid transferring large parameters between processes and allows access to resources that may only exist on a specific worker.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"We follow a similar procedure as with the algorithm interface, but we will not configure the parameters just yet.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"pre = RecoPlan(RadonPreprocessingParameters)\niter_reco = RecoPlan(IterativeRadonReconstructionParameters)\nparams = RecoPlan(IterativeRadonParameters; pre = pre, reco = iter_reco)\nplan_iter = RecoPlan(IterativeRadonAlgorithm, parameter = params)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"We can traverse the parameters of our algorithm and configure them locally:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"plan_iter.parameter.pre.frames = collect(1:3)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"To transfer the plan to the worker process, we will use DaggerReconstructionParameter and DaggerReconstructionAlgorithm as a RecoPlan:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"params_dagger = RecoPlan(DaggerReconstructionParameter; worker = worker, algo = plan_iter)\nplan_dagger = RecoPlan(DaggerReconstructionAlgorithm; parameter = params_dagger)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"In this setup, only the DaggerReconstructionParameter and DaggerReconstructionAlgorithm exist on the local worker; all other RecoPlans reside on the chosen worker. When traversing the RecoPlan tree across workers, we receive a DaggerRecoPlan instead of the usual data type:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"typeof(plan_dagger.parameter.algo)\n\n#This ephemeral structure manages communication with its remote `RecoPlan` counterpart, allowing us to use the same interface as if the entire plan were local.\nplan_dagger.parameter.algo.parameter.reco.solver = CGNR\n\ndict = Dict{Symbol, Any}()\ndict[:shape] = size(images)[1:3]\ndict[:angles] = angles\ndict[:iterations] = 20\ndict[:reg] = [L2Regularization(0.001)]\ndict[:solver] = CGNR\nsetAll!(plan_dagger, dict)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"To configure the algorithm with resources only available on the worker, such as files or GPU data, we can use the following interface:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"setproperty!(plan_dagger.parameter.algo.parameter.reco, :angles) do\n  angles[1:2:end]\nend\nlength(plan_dagger.parameter.algo.parameter.reco.angles) == length(1:2:length(angles))","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"The provided function is evaluated solely on the remote worker.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"Once the algorithm is fully configured, we can build and use it as usual:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"setAll!(plan_dagger, dict)\nimag_dagger = reconstruct(build(plan_dagger), sinograms)\nfig = Figure()\nfor i = 1:3\n  plot_image(fig[i,1], reverse(images[:, :, 24, i]))\n  plot_image(fig[i,2], sinograms[:, :, 24, i])\n  plot_image(fig[i,3], reverse(imag_dagger[:, :, 24, i]))\nend\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"generated/example/daggerplan/#Serialization","page":"RecoPlan Interface","title":"Serialization","text":"","category":"section"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"The serialization process of DaggerReconstructionAlgorithm and DaggerReconstructionParameter ignores the worker parameter and retrieves the entire plan tree:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"toTOML(stdout, plan_dagger)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"It is also possible to directly load and distribute a serialized plan from a file using:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"loadDaggerPlan(filename, modules; worker = worker)","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"This automatically wraps everything in a DaggerReconstructionAlgorithm.","category":"page"},{"location":"generated/example/daggerplan/#Observables","page":"RecoPlan Interface","title":"Observables","text":"","category":"section"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"RecoPlans can attach callbacks to property value changes using Observables from Observables.jl. If a RecoPlan is set up with listeners and then moved to a different worker, the plans execute within that worker. This functionality also applies to the loadDaggerPlan method mentioned earlier.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"Additionally, listeners can be attached across workers using the Observable interface on a DaggerRecoPlan:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"using Observables\nlocalVariable = 3\nplan_iter_remote = plan_dagger.parameter.algo\nfun = on(plan_iter_remote.parameter.pre, :frames) do newval\n  @info \"Number of frames was updated to: $(length(newval))\"\n  localVariable = length(newval)\nend\nsetAll!(plan_iter_remote, :frames, collect(1:42))","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"Note: We retain the observable function in the variable fun to allow for later removal of the listener. The anonymous function cannot be used directly due to internal listener management in DaggerImageReconstruction.","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"off(plan_iter_remote.parameter.pre, :frames, fun)\nsetAll!(plan_iter_remote, :frames, collect(1:32))","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"Since the listener executes on the local worker, updated data must be transferred between workers. If this involves large data, a preprocessing function can be provided to the Observable:","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"fun = on(plan_iter_remote.parameter.pre, :frames; preprocessing = length) do newval\n  @info \"Number of frames was updated to: $(newval)\"\n  localVariable = newval\nend\nsetAll!(plan_iter_remote, :frames, collect(1:42))","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"","category":"page"},{"location":"generated/example/daggerplan/","page":"RecoPlan Interface","title":"RecoPlan Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example_intro/#Distributed-Radon-Image-Reconstruction","page":"Introduction","title":"Distributed Radon Image Reconstruction","text":"","category":"section"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"In this example, we will build upon the Radon example from AbstractImageReconstruction. We will demonstrate how our reconstruction package, OurRadonReco, can be distributed across multiple processes.","category":"page"},{"location":"example_intro/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"In addition to the packages from the Radon example, you need to add DaggerImageReconstruction using the Julia package manager. Open a Julia REPL and execute the following command:","category":"page"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"DaggerImageReconstruction\")","category":"page"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"This command will download and install DaggerImageReconstruction.jl along with its dependencies.","category":"page"},{"location":"example_intro/#Required-Packages","page":"Introduction","title":"Required Packages","text":"","category":"section"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"You will also need to install the necessary packages for the Radon example. Please refer to the example documentation for specific installation steps.","category":"page"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"Note that there is no direct dependency between OurRadonReco and DaggerImageReconstruction. While it is possible to specialize parts of the image reconstruction through package extensions, the core functionality is provided solely via the AbstractImageReconstruction interface.","category":"page"},{"location":"example_intro/#Environment-Setup","page":"Introduction","title":"Environment Setup","text":"","category":"section"},{"location":"example_intro/","page":"Introduction","title":"Introduction","text":"Ensure that the required packages are installed in the environment of both Julia processes. For detailed instructions on launching Julia processes across different workers or computers, consult the Distributed Computing documentation.","category":"page"},{"location":"API/api/#API-for-DaggerImageReconstruction","page":"API Reference","title":"API for DaggerImageReconstruction","text":"","category":"section"},{"location":"API/api/","page":"API Reference","title":"API Reference","text":"This page contains documentation of the public API of the AbstractImageReconstruction. In the Julia REPL one can access this documentation by entering the help mode with ?","category":"page"},{"location":"API/api/#Algorithm-and-Parameters","page":"API Reference","title":"Algorithm and Parameters","text":"","category":"section"},{"location":"API/api/#DaggerImageReconstruction.DaggerReconstructionAlgorithm","page":"API Reference","title":"DaggerImageReconstruction.DaggerReconstructionAlgorithm","text":"DaggerReconstructionAlgorithm\n\nStruct representing a Dagger-based reconstruction algorithm, which encapsulates the distrubted reconstruction execution and manages the outputs.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#DaggerImageReconstruction.DaggerReconstructionParameter","page":"API Reference","title":"DaggerImageReconstruction.DaggerReconstructionParameter","text":"DaggerReconstructionParameter\n\nStruct representing parameters for a Dagger-based reconstruction algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#DaggerRecoPlan","page":"API Reference","title":"DaggerRecoPlan","text":"","category":"section"},{"location":"API/api/#DaggerImageReconstruction.DaggerRecoPlan","page":"API Reference","title":"DaggerImageReconstruction.DaggerRecoPlan","text":"DaggerRecoPlan{T}\n\nA configuration template for an image reconstruction algorithm or parameters of type T in a different Julia process. \n\nThe DaggerRecoPlan{T} struct provides an interface similar to that of a RecoPlan, with the key distinction that setting and getting properties results in transparent data transfer to the specified remote process. DaggerRecoPlans are temporary data structures that are recreated whenever traversing the remote RecoPlan tree. They track no state, except for the reference to their remote RecoPlan counterpart.\n\n\n\n\n\n","category":"type"},{"location":"API/api/#Base.getproperty-Tuple{DaggerRecoPlan, Symbol}","page":"API Reference","title":"Base.getproperty","text":"Base.getproperty(plan::DaggerRecoPlan, name::Symbol)\n\nGet the property name of the counterpart plan. If the property is another RecoPlan, this returns a new DaggerRecoPlan pointing to the RecoPlan property.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Base.setproperty!-Tuple{DaggerRecoPlan, Symbol, Any}","page":"API Reference","title":"Base.setproperty!","text":"Base.setproperty!(plan::DaggerRecoPlan, name::Symbol, x)\n\nSet the property name of the remote plan to x. Equivalent to plan.name = x. Triggers callbacks attached to the property.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#Observables.on-Tuple{Any, DaggerRecoPlan, Symbol}","page":"API Reference","title":"Observables.on","text":"on(f, plan::DaggerRecoPlan, property::Symbol; preprocessing = identity, kwargs...)\n\nRegisters a callback function f to be executed whenever the specified property of the given plan changes. The function f will be executed with the new value of the property on the current worker. Returns a Dagger.Chunk of the ObservableFunction. This chunk is required to unregister the listener f\n\nTo preprocess the data before it is passed to f, use the preprocessing keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"API/api/#DaggerImageReconstruction.loadDaggerPlan","page":"API Reference","title":"DaggerImageReconstruction.loadDaggerPlan","text":"loadDaggerPlan(filename; worker)\n\nLoad a local RecoPlan from the specified filename and interpret it on the designated worker. The resulting RecoPlan is encapsulated within a DaggerReconstructionAlgorithm.\n\n\n\n\n\n","category":"function"},{"location":"#DaggerImageReconstruction.jl","page":"Home","title":"DaggerImageReconstruction.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Distributed Image Reconstruction for Medical Image Reconstruction Packages","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DaggerImageReconstruction.jl is a Julia package that enables distributed image reconstruction using AbstractImageReconstruction.jl across multiple Julia processes and machines. This flexibility allows users to configure image reconstruction locally while executing it on a remote machine, such as one with GPU acceleration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any algorithm developed with AbstractImageReconstruction is compatible, including all algorithms from MPIReco.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package leverages the Distributed.jl standard library and Dagger.jl for its functionality.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transparent data movement during image reconstruction \nSeamless usage of RecoPlans across processes, including tree traversal and observables\nLoading of local algorithms configuration on remote processes","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, use Julia's package manager. Open the Julia REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DaggerImageReconstruction\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use DaggerImageReconstruction.jl, one first needs to add a new Julia process using Distributed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Add new process (on remote server)\nusing Distributed\nworker = first(addprocs([\"gpuServer\"]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Afterwards one can load `DaggerImageReconstructionÂ´ and the packages implementing specific image reconstruction algorithms, such as MPIReco.jl. Similar to AbstractImageReconstruction.jl, this package does not offer concrete reconstruction algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DaggerImageReconstruction\n@everywhere using AbstractImageReconstruction, ... # Load Reco packages\n\nplan = loadDaggerPlan(\"plan.toml\", ...; worker = worker)\n\n# Transparently configure algorithm in the remote process\ndict = Dict{Symbol, Any}()\ndict[:iterations] = 20\ndict[:file] = () -> File(\"path/on/remote\")\nsetAll!(plan, dict)\n\ndata = ... # read local data\n\n# Transfer data to the remote, reconstruct there and return the result\nalgo = build(plan)\nimage = reconstruct(algo, raw)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithms can be parameterized and constructed as if they were local RecoPlans. The example above demonstrates moving the entire image reconstruction to another process. DaggerImageReconstruction also provides an AbstractUtilityReconstructionParameters to transfer individual processing steps to another process.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! If you would like to contribute to DaggerImageReconstruction.jl, please fork the repository and create a pull request.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is built on top of Dagger.jl, which provides the framefork for the distributed computations.","category":"page"}]
}
